<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WTG Planner – klastry turbin</title>

  <!-- PROSTE STYLE (bez style.css) -->
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .control-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 10px;
      border-radius: 8px;
      max-width: 360px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      backdrop-filter: blur(4px);
    }

    .control-panel h1 {
      font-size: 16px;
      margin: 0 0 6px 0;
    }

    .control-panel textarea {
      width: 100%;
      min-height: 70px;
      resize: vertical;
      border-radius: 4px;
      border: none;
      padding: 5px;
      font-family: monospace;
      font-size: 12px;
    }

    .control-panel button {
      margin-top: 6px;
      margin-right: 4px;
      padding: 6px 10px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-size: 12px;
    }

    .control-panel button.primary {
      background: #1f6feb;
      color: white;
    }

    .control-panel button.secondary {
      background: #30363d;
      color: white;
    }

    .control-panel .info {
      font-size: 11px;
      margin-top: 4px;
      opacity: 0.85;
    }

    .list-title {
      font-size: 11px;
      font-weight: 600;
      margin-top: 6px;
    }

    .list {
      margin: 2px 0 0 16px;
      padding: 0;
      max-height: 110px;
      overflow-y: auto;
      font-size: 11px;
    }

    .list li {
      margin-bottom: 2px;
    }
  </style>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
</head>
<body>

  <div id="map"></div>

  <div class="control-panel">
    <h1>WTG Planner</h1>
    <div class="info">
      Wpisz ID turbin (np. <b>208217</b>), po jednym w linii<br>
      albo oddzielone spacją / przecinkiem.
    </div>
    <textarea id="wtgInput" placeholder="208217
13460
13461"></textarea>
    <div>
      <button id="showBtn" class="primary">Pokaż plan dnia</button>
      <button id="clearBtn" class="secondary">Wyczyść</button>
    </div>
    <div class="info" id="statusInfo"></div>

    <div class="list-title">Kolejność klastrów (gdzie jechać po kolei):</div>
    <ol id="clusterList" class="list"></ol>

    <div class="list-title">Szczegółowa kolejność turbin:</div>
    <ol id="routeList" class="list"></ol>
  </div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    const CLUSTER_RADIUS_KM = 30; // promień klastra wg Twojego życzenia

    const statusInfo = document.getElementById("statusInfo");
    const input = document.getElementById("wtgInput");
    const showBtn = document.getElementById("showBtn");
    const clearBtn = document.getElementById("clearBtn");
    const clusterList = document.getElementById("clusterList");
    const routeList = document.getElementById("routeList");

    let map;
    let markersLayer;
    let routePolyline;
    const wtgById = new Map(); // id -> { id, lat, lng }

    async function init() {
      // mapa z wyłączonym domyślnym zoomem, dodamy swój w prawym górnym rogu
      map = L.map("map", { zoomControl: false }).setView([52.0, 19.0], 5);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap"
      }).addTo(map);

      // plus/minus do przybliżania
      L.control.zoom({
        position: "topright"
      }).addTo(map);

      markersLayer = L.layerGroup().addTo(map);

      try {
        const resp = await fetch("data.json");
        const data = await resp.json();
        const list = data.wtg || [];

        list.forEach(w => {
          if (typeof w.lat === "number" && typeof w.lng === "number" && w.id) {
            wtgById.set(String(w.id), w);
          }
        });

        statusInfo.textContent = `Załadowano ${wtgById.size} turbin. Wklej ID, a zaplanuję dzień wg klastrów (~${CLUSTER_RADIUS_KM} km).`;
      } catch (e) {
        console.error(e);
        statusInfo.textContent = "Błąd ładowania data.json";
      }
    }

    function parseIds(text) {
      return text
        .split(/[\s,;]+/)
        .map(t => t.trim())
        .filter(t => t.length > 0);
    }

    // Haversine – odległość w km
    function distanceKm(a, b) {
      const R = 6371;
      const toRad = deg => deg * Math.PI / 180;
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat);
      const lat2 = toRad(b.lat);

      const sinDLat = Math.sin(dLat / 2);
      const sinDLng = Math.sin(dLng / 2);

      const h = sinDLat * sinDLat +
        Math.cos(lat1) * Math.cos(lat2) *
        sinDLng * sinDLng;

      const c = 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
      return R * c;
    }

    // Prosta trasa wewnątrz zbioru punktów: start = pierwszy, potem zawsze najbliższy
    function buildRoute(points) {
      if (points.length === 0) return [];

      const route = [];
      const unvisited = points.slice(); // kopia

      let current = unvisited.shift(); // start: pierwszy z listy
      route.push(current);

      while (unvisited.length > 0) {
        let bestIndex = 0;
        let bestDist = Infinity;

        for (let i = 0; i < unvisited.length; i++) {
          const d = distanceKm(current, unvisited[i]);
          if (d < bestDist) {
            bestDist = d;
            bestIndex = i;
          }
        }

        current = unvisited.splice(bestIndex, 1)[0];
        route.push(current);
      }

      return route;
    }

    // Budowanie klastrów: bierzemy pierwszy punkt, wszystko w promieniu CLUSTER_RADIUS_KM do jednego klastra
    function buildClusters(points) {
      const unassigned = points.slice();
      const clusters = [];

      while (unassigned.length > 0) {
        const seed = unassigned.shift();
        const clusterPoints = [seed];
        const remaining = [];

        for (const p of unassigned) {
          const d = distanceKm(seed, p);
          if (d <= CLUSTER_RADIUS_KM) {
            clusterPoints.push(p);
          } else {
            remaining.push(p);
          }
        }

        clusters.push({ points: clusterPoints });
        unassigned.length = 0;
        Array.prototype.push.apply(unassigned, remaining);
      }

      // centroidy klastrów
      clusters.forEach(c => {
        let lat = 0, lng = 0;
        c.points.forEach(p => { lat += p.lat; lng += p.lng; });
        lat /= c.points.length;
        lng /= c.points.length;
        c.center = { lat, lng };
      });

      return clusters;
    }

    // Ułożenie klastrów w kolejności – start od pierwszego, potem najbliższy kolejny
    function orderClusters(clusters) {
      if (clusters.length === 0) return [];

      const remaining = clusters.slice();
      const ordered = [];

      let current = remaining.shift();
      ordered.push(current);

      while (remaining.length > 0) {
        let bestIndex = 0;
        let bestDist = Infinity;

        for (let i = 0; i < remaining.length; i++) {
          const d = distanceKm(current.center, remaining[i].center);
          if (d < bestDist) {
            bestDist = d;
            bestIndex = i;
          }
        }

        current = remaining.splice(bestIndex, 1)[0];
        ordered.push(current);
      }

      return ordered;
    }

    function showSelected() {
      const ids = parseIds(input.value);
      markersLayer.clearLayers();
      clusterList.innerHTML = "";
      routeList.innerHTML = "";
      if (routePolyline) {
        map.removeLayer(routePolyline);
        routePolyline = null;
      }

      if (ids.length === 0) {
        statusInfo.textContent = "Brak ID do wyświetlenia.";
        return;
      }

      // mapujemy ID -> punkty
      const points = [];
      ids.forEach(idRaw => {
        const id = String(idRaw);
        const w = wtgById.get(id);
        if (w) {
          points.push({ id, lat: w.lat, lng: w.lng });
        }
      });

      if (points.length === 0) {
        statusInfo.textContent = "Nie znaleziono żadnej turbiny dla podanych ID.";
        return;
      }

      // klastry i ich kolejność
      const clusters = buildClusters(points);
      const orderedClusters = orderClusters(clusters);

      // budujemy trasę globalną: w każdym klastrze lokalna trasa -> składamy
      const fullRoute = [];
      let totalDist = 0;

      orderedClusters.forEach((cluster, clusterIndex) => {
        const localRoute = buildRoute(cluster.points);
        cluster.route = localRoute;

        // wyliczamy dystans wewnątrz klastra
        for (let i = 1; i < localRoute.length; i++) {
          totalDist += distanceKm(localRoute[i - 1], localRoute[i]);
        }

        // dokładamy do trasy globalnej
        localRoute.forEach(p => {
          fullRoute.push({
            id: p.id,
            lat: p.lat,
            lng: p.lng,
            clusterIndex
          });
        });
      });

      // dystans między klastrami (między ostatnim punktu jednego a pierwszym następnego)
      for (let i = 1; i < orderedClusters.length; i++) {
        const prevCluster = orderedClusters[i - 1];
        const currCluster = orderedClusters[i];
        const prevLast = prevCluster.route[prevCluster.route.length - 1];
        const currFirst = currCluster.route[0];
        totalDist += distanceKm(prevLast, currFirst);
      }

      // markerki i linia trasy
      const markers = [];
      fullRoute.forEach((p, idx) => {
        const marker = L.marker([p.lat, p.lng]).addTo(markersLayer);
        marker.bindPopup(`<b>${idx + 1}. ${p.id}</b><br/>Klaster ${p.clusterIndex + 1}`);
        markers.push(marker);
      });

      if (markers.length > 0) {
        const group = L.featureGroup(markers);
        map.fitBounds(group.getBounds().pad(0.1));
      }

      if (fullRoute.length > 1) {
        const lineLatLngs = fullRoute.map(p => [p.lat, p.lng]);
        routePolyline = L.polyline(lineLatLngs, { weight: 2 }).addTo(map);
      }

      // lista klastrów w panelu – „jedź najpierw tu, bo X turbin”
      orderedClusters.forEach((cluster, idx) => {
        const li = document.createElement("li");
        const idsInCluster = cluster.route.map(p => p.id).join(", ");
        li.textContent = `Klaster ${idx + 1}: ${cluster.points.length} turbiny – ${idsInCluster}`;
        clusterList.appendChild(li);
      });

      // lista szczegółowa – kolejność wszystkich turbin
      fullRoute.forEach((p, idx) => {
        const li = document.createElement("li");
        li.textContent = `${idx + 1}. ${p.id} (klaster ${p.clusterIndex + 1})`;
        routeList.appendChild(li);
      });

      const distRounded = Math.round(totalDist);
      statusInfo.textContent = `Klastry: ${orderedClusters.length}, turbiny: ${fullRoute.length}. Szacowana długość trasy: ~${distRounded} km (heurystyka, promień klastra ${CLUSTER_RADIUS_KM} km).`;
    }

    function clearMap() {
      markersLayer.clearLayers();
      clusterList.innerHTML = "";
      routeList.innerHTML = "";
      if (routePolyline) {
        map.removeLayer(routePolyline);
        routePolyline = null;
      }
      statusInfo.textContent = "Mapa wyczyszczona. Wklej ID i kliknij „Pokaż plan dnia”.";
    }

    document.addEventListener("DOMContentLoaded", () => {
      init();
      showBtn.addEventListener("click", showSelected);
      clearBtn.addEventListener("click", clearMap);
    });
  </script>
</body>
</html>
