<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WTG Planner – plan dnia</title>

  <!-- STYLE -->
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: system-ui, sans-serif;
      background: #000;
    }

    #app {
      width: 100%;
      height: 100%;
      display: none; /* pokażemy dopiero po zalogowaniu */
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .control-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(0, 0, 0, 0.78);
      color: #fff;
      padding: 10px;
      border-radius: 8px;
      max-width: 360px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.6);
      backdrop-filter: blur(6px);
    }

    .control-panel h1 {
      font-size: 18px;
      margin: 0 0 6px 0;
    }

    .control-panel textarea {
      width: 100%;
      min-height: 70px;
      resize: vertical;
      border-radius: 4px;
      border: none;
      padding: 5px;
      font-family: monospace;
      font-size: 12px;
    }

    .control-panel button {
      margin-top: 6px;
      margin-right: 4px;
      padding: 6px 10px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-size: 12px;
    }

    .control-panel button.primary {
      background: #1f6feb;
      color: #fff;
    }

    .control-panel button.secondary {
      background: #444;
      color: #fff;
    }

    .info {
      font-size: 11px;
      margin-top: 4px;
      opacity: 0.85;
    }

    .list-title {
      font-size: 11px;
      font-weight: 600;
      margin-top: 6px;
    }

    .list {
      margin: 2px 0 0 16px;
      padding: 0;
      max-height: 110px;
      overflow-y: auto;
      font-size: 11px;
    }

    .list li {
      margin-bottom: 2px;
    }

    /* ====== LOGIN ====== */

    #loginScreen {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #222 0, #000 60%);
      color: #fff;
      z-index: 2000;
    }

    .login-box {
      background: rgba(10,10,10,0.9);
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.7);
      width: 320px;
    }

    .login-box h2 {
      margin: 0 0 10px 0;
      font-size: 20px;
      text-align: center;
    }

    .login-box label {
      display: block;
      font-size: 13px;
      margin-top: 8px;
    }

    .login-box input {
      width: 100%;
      padding: 6px 8px;
      margin-top: 2px;
      border-radius: 4px;
      border: 1px solid #333;
      background: #111;
      color: #fff;
      font-size: 13px;
    }

    .login-box button {
      width: 100%;
      margin-top: 12px;
      padding: 8px;
      border-radius: 6px;
      border: none;
      background: #1f6feb;
      color: #fff;
      font-size: 14px;
      cursor: pointer;
    }

    .login-box button:hover {
      background: #255fd1;
    }

    .login-error {
      margin-top: 6px;
      font-size: 12px;
      color: #ff6b6b;
      min-height: 16px;
      text-align: center;
    }

    .login-hint {
      margin-top: 8px;
      font-size: 11px;
      opacity: 0.7;
      text-align: center;
    }

    #gmapsLinks a {
      color: #58a6ff;
      text-decoration: none;
      font-size: 11px;
    }

    #gmapsLinks a:hover {
      text-decoration: underline;
    }
  </style>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
</head>
<body>

<!-- ====== EKRAN LOGOWANIA ====== -->
<div id="loginScreen">
  <div class="login-box">
    <h2>WTG Planner – logowanie</h2>

    <label for="loginUser">Login</label>
    <input id="loginUser" type="text" autocomplete="username" />

    <label for="loginPass">Hasło</label>
    <input id="loginPass" type="password" autocomplete="current-password" />

    <button id="loginBtn">Zaloguj</button>

    <div id="loginError" class="login-error"></div>

    <div class="login-hint">
      (domyślnie: login <b>phobian</b>, hasło <b>phobian123</b> – możesz zmienić w kodzie)
    </div>
  </div>
</div>

<!-- ====== APLIKACJA ====== -->
<div id="app">
  <div id="map"></div>

  <div class="control-panel">
    <h1>WTG Planner</h1>

    <div class="info">
      Wpisz ID turbin (np. <b>208217</b>), po jednym w linii<br />
      albo oddzielone spacją / przecinkiem.
    </div>

    <textarea id="wtgInput" placeholder="208217&#10;13460&#10;13461"></textarea>

    <div>
      <button id="showBtn" class="primary">Pokaż plan dnia</button>
      <button id="clearBtn" class="secondary">Wyczyść</button>
      <button id="gmapsBtn" class="secondary">Google Maps</button>
    </div>

    <div class="info" id="statusInfo"></div>

    <div class="list-title">Kolejność klastrów (gdzie jechać po kolei):</div>
    <ol id="clusterList" class="list"></ol>

    <div class="list-title">Szczegółowa kolejność turbin:</div>
    <ol id="routeList" class="list"></ol>

    <div class="list-title">Linki do trasy w Google Maps:</div>
    <div id="gmapsLinks" class="info"></div>
  </div>
</div>

<!-- Leaflet JS -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<script>
  /* ========= KONFIG LOGOWANIA =========
     LOGIN: phobian
     HASŁO: phobian123
     HASH = SHA-256("phobian123")
  */
  const AUTH_USER = "phobian";
  const AUTH_HASH = "121a2b8d26b5e8f388f029fe0a7115fdf108da3eef5cdcf58ee182f7a305ef4e";

  async function sha256Hex(str) {
    const enc = new TextEncoder().encode(str);
    const buf = await crypto.subtle.digest("SHA-256", enc);
    const arr = Array.from(new Uint8Array(buf));
    return arr.map(b => b.toString(16).padStart(2, "0")).join("");
  }

  async function handleLogin() {
    const userInput = document.getElementById("loginUser").value.trim();
    const passInput = document.getElementById("loginPass").value;
    const err       = document.getElementById("loginError");

    if (!userInput || !passInput) {
      err.textContent = "Podaj login i hasło.";
      return;
    }

    try {
      const hash = await sha256Hex(passInput);

      if (userInput === AUTH_USER && hash === AUTH_HASH) {
        err.textContent = "";
        document.getElementById("loginScreen").style.display = "none";
        document.getElementById("app").style.display = "block";
        init();
      } else {
        err.textContent = "Nieprawidłowy login lub hasło.";
      }
    } catch (e) {
      console.error(e);
      err.textContent = "Błąd logowania (SHA-256).";
    }
  }

  // ====== PLANER TURBIN ======

  const CLUSTER_RADIUS_KM = 30;

  const statusInfo  = document.getElementById("statusInfo");
  const input       = document.getElementById("wtgInput");
  const showBtn     = document.getElementById("showBtn");
  const clearBtn    = document.getElementById("clearBtn");
  const gmapsBtn    = document.getElementById("gmapsBtn");
  const clusterList = document.getElementById("clusterList");
  const routeList   = document.getElementById("routeList");
  const gmapsLinks  = document.getElementById("gmapsLinks");

  let map;
  let markersLayer;
  let routePolyline;
  const wtgById = new Map();
  let lastFullRoute = [];

  async function init() {
    map = L.map("map", { zoomControl: false }).setView([52.0, 19.0], 5);

    L.tileLayer(
      "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{x}/{y}",
      {
        maxZoom: 19,
        attribution: "Tiles © Esri - World Imagery"
      }
    ).addTo(map);

    L.control.zoom({ position: "topright" }).addTo(map);

    markersLayer = L.layerGroup().addTo(map);

    try {
      const resp = await fetch("data.json");
      const data = await resp.json();
      const list = data.wtg || [];

      list.forEach(w => {
        if (w.id && typeof w.lat === "number" && typeof w.lng === "number") {
          wtgById.set(String(w.id), w);
        }
      });

      statusInfo.textContent =
        "Załadowano " + wtgById.size +
        " turbin. Wklej ID, a ułożę dzień (klastry ~" +
        CLUSTER_RADIUS_KM + " km).";
    } catch (e) {
      console.error(e);
      statusInfo.textContent = "Błąd ładowania data.json";
    }
  }

  function parseIds(text) {
    return text
      .split(/[\s,;]+/)
      .map(t => t.trim())
      .filter(t => t.length > 0);
  }

  function distanceKm(a, b) {
    const R = 6371;
    const toRad = deg => deg * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLng = toRad(b.lng - a.lng);
    const lat1 = toRad(a.lat);
    const lat2 = toRad(b.lat);

    const sinDLat = Math.sin(dLat / 2);
    const sinDLng = Math.sin(dLng / 2);

    const h = sinDLat * sinDLat +
      Math.cos(lat1) * Math.cos(lat2) *
      sinDLng * sinDLng;

    const c = 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
    return R * c;
  }

  function buildRoute(points) {
    if (points.length === 0) return [];

    const route = [];
    const unvisited = points.slice();

    let current = unvisited.shift();
    route.push(current);

    while (unvisited.length > 0) {
      let bestIndex = 0;
      let bestDist  = Infinity;

      for (let i = 0; i < unvisited.length; i++) {
        const d = distanceKm(current, unvisited[i]);
        if (d < bestDist) {
          bestDist  = d;
          bestIndex = i;
        }
      }

      current = unvisited.splice(bestIndex, 1)[0];
      route.push(current);
    }

    return route;
  }

  function buildClusters(points) {
    const unassigned = points.slice();
    const clusters   = [];

    while (unassigned.length > 0) {
      const seed = unassigned.shift();
      const clusterPoints = [seed];
      const remaining = [];

      for (const p of unassigned) {
        const d = distanceKm(seed, p);
        if (d <= CLUSTER_RADIUS_KM) {
          clusterPoints.push(p);
        } else {
          remaining.push(p);
        }
      }

      clusters.push({ points: clusterPoints });
      unassigned.length = 0;
      Array.prototype.push.apply(unassigned, remaining);
    }

    clusters.forEach(c => {
      let lat = 0, lng = 0;
      c.points.forEach(p => { lat += p.lat; lng += p.lng; });
      lat /= c.points.length;
      lng /= c.points.length;
      c.center = { lat, lng };
    });

    return clusters;
  }

  function orderClusters(clusters) {
    if (clusters.length === 0) return [];

    const remaining = clusters.slice();
    const ordered   = [];

    let current = remaining.shift();
    ordered.push(current);

    while (remaining.length > 0) {
      let bestIndex = 0;
      let bestDist  = Infinity;

      for (let i = 0; i < remaining.length; i++) {
        const d = distanceKm(current.center, remaining[i].center);
        if (d < bestDist) {
          bestDist  = d;
          bestIndex = i;
        }
      }

      current = remaining.splice(bestIndex, 1)[0];
      ordered.push(current);
    }

    return ordered;
  }

  function showSelected() {
    const ids = parseIds(input.value);
    markersLayer.clearLayers();
    clusterList.innerHTML = "";
    routeList.innerHTML   = "";
    gmapsLinks.innerHTML  = "";
    lastFullRoute = [];
    if (routePolyline) {
      map.removeLayer(routePolyline);
      routePolyline = null;
    }

    if (ids.length === 0) {
      statusInfo.textContent = "Brak ID do wyświetlenia.";
      return;
    }

    const points = [];
    ids.forEach(idRaw => {
      const id = String(idRaw);
      const w  = wtgById.get(id);
      if (w) {
        points.push({ id, lat: w.lat, lng: w.lng });
      }
    });

    if (points.length === 0) {
      statusInfo.textContent = "Nie znaleziono żadnej turbiny dla podanych ID.";
      return;
    }

    const clusters        = buildClusters(points);
    const orderedClusters = orderClusters(clusters);

    const fullRoute = [];
    let   totalDist = 0;

    orderedClusters.forEach((cluster, clusterIndex) => {
      const localRoute = buildRoute(cluster.points);
      cluster.route = localRoute;

      for (let i = 1; i < localRoute.length; i++) {
        totalDist += distanceKm(localRoute[i - 1], localRoute[i]);
      }

      localRoute.forEach(p => {
        fullRoute.push({
          id: p.id,
          lat: p.lat,
          lng: p.lng,
          clusterIndex: clusterIndex
        });
      });
    });

    for (let i = 1; i < orderedClusters.length; i++) {
      const prevCluster = orderedClusters[i - 1];
      const currCluster = orderedClusters[i];
      const prevLast    = prevCluster.route[prevCluster.route.length - 1];
      const currFirst   = currCluster.route[0];
      totalDist += distanceKm(prevLast, currFirst);
    }

    lastFullRoute = fullRoute;

    const markers = [];
    fullRoute.forEach((p, idx) => {
      const marker = L.marker([p.lat, p.lng]).addTo(markersLayer);
      marker.bindPopup(
        "<b>" + (idx + 1) + ". " + p.id + "</b><br/>Klaster " + (p.clusterIndex + 1)
      );
      markers.push(marker);
    });

    if (markers.length > 0) {
      const group = L.featureGroup(markers);
      map.fitBounds(group.getBounds().pad(0.15));
    }

    if (fullRoute.length > 1) {
      const lineLatLngs = fullRoute.map(p => [p.lat, p.lng]);
      routePolyline = L.polyline(lineLatLngs, { weight: 2, color: "#00bcd4" }).addTo(map);
    }

    orderedClusters.forEach((cluster, idx) => {
      const li = document.createElement("li");
      const idsInCluster = cluster.route.map(p => p.id).join(", ");
      li.textContent = "Klaster " + (idx + 1) + ": " +
        cluster.points.length + " turbiny – " + idsInCluster;
      clusterList.appendChild(li);
    });

    fullRoute.forEach((p, idx) => {
      const li = document.createElement("li");
      li.textContent = (idx + 1) + ". " + p.id +
        " (klaster " + (p.clusterIndex + 1) + ")";
      routeList.appendChild(li);
    });

    const distRounded = Math.round(totalDist);
    statusInfo.textContent =
      "Klastry: " + orderedClusters.length +
      ", turbiny: " + fullRoute.length +
      ". Szacowana długość trasy: ~" + distRounded +
      " km (promień klastra " + CLUSTER_RADIUS_KM + " km).";
  }

  function clearMap() {
    markersLayer.clearLayers();
    clusterList.innerHTML = "";
    routeList.innerHTML   = "";
    gmapsLinks.innerHTML  = "";
    lastFullRoute = [];
    if (routePolyline) {
      map.removeLayer(routePolyline);
      routePolyline = null;
    }
    statusInfo.textContent =
      "Mapa wyczyszczona. Wklej ID i kliknij „Pokaż plan dnia”.";
  }

  function generateGoogleLinks() {
    gmapsLinks.innerHTML = "";

    if (!lastFullRoute || lastFullRoute.length === 0) {
      statusInfo.textContent = "Najpierw wygeneruj plan dnia, potem kliknij Google Maps.";
      return;
    }

    const maxPerUrl = 10;
    const total = lastFullRoute.length;
    let html = "";

    for (let i = 0; i < total; i += maxPerUrl) {
      const seg = lastFullRoute.slice(i, i + maxPerUrl);
      if (seg.length === 0) continue;

      let url = "https://www.google.com/maps/dir/";
      seg.forEach(p => {
        const coord = p.lat.toFixed(6) + "," + p.lng.toFixed(6);
        url += encodeURIComponent(coord) + "/";
      });

      const startIdx = i + 1;
      const endIdx = i + seg.length;
      const label = "Segment " + startIdx + "–" + endIdx;

      html +=
        '<div><a href="' + url +
        '" target="_blank" rel="noopener noreferrer">' +
        label + "</a></div>";
    }

    gmapsLinks.innerHTML = html;
    statusInfo.textContent =
      statusInfo.textContent + " | Wygenerowano linki do Google Maps (max 10 punktów na link).";
  }

  document.addEventListener("DOMContentLoaded", () => {
    document.getElementById("loginBtn")
      .addEventListener("click", handleLogin);

    document.getElementById("loginPass")
      .addEventListener("keydown", e => {
        if (e.key === "Enter") {
          e.preventDefault();
          handleLogin();
        }
      });

    showBtn.addEventListener("click", showSelected);
    clearBtn.addEventListener("click", clearMap);
    gmapsBtn.addEventListener("click", generateGoogleLinks);
  });
</script>

</body>
</html>
